


#_________________________________________________________________
# tempFile v1.0 ( 2024.11.9 ) ####################################
#
#	by digi_cs 2024
#
#	THIS LIBRARY REQUIRES ANOTHER LIBRARIES TO BE INCLUDED:
#
#		class.lib			github.com/digics/CLASS
#
#_______________________________________________
#
#
#_________________________________________________________________
func	envmod::tempFile( C ) { ####################################

	C[ "rq" ]		= "base" }

#_________________________________________________________________
##################################################################

	@namespace "tempFile"

#_________________________________________________________________
BEGIN{ ###########################################################

	init0()

}#________________________________________________________________
func	init0() { ##################################################

	if ( ! init0_f ) {

		init0_f = 1

		LIB			= "tempFile"

		ERROR_OUT		= "/dev/stderr" #_default( ERROR_OUT	, STDERR )

		librq( "base" )

		ptr			= _::def( LIB, "", "<", ">" ) } }

#_________________________________________________________________
func	_def( n, pp, px, sx ,p ) { #################################

	#trace( 6, n, pp, px, sx ,p2,p3 )

	print "\t" API ": in"

	_::api()

	p = @API( n, pp, px, sx )

	print "\t" "tempFile::def: OUT"

	"" in _FILENAME

	return p }

#_____________________________________________________
func	_new( pp, p ) { ################################

	print "\t" API ": IN"

	p = base::ppapi1( pp, p )

	print "\t" "tempFile::new: OUT"

	_FILENAME[ p ] = p

	return p }

#_____________________________________________________
func	_del( p ) { ####################################

	# delete file: _FILENAME[ p ]

	print "\t" API ": in"

	delete _FILENAME[ p ]

	p = base::ppapi0( p )

	print "\t" "tempFile::del: OUT"

	return p }






#_________________________________________________________________
func	typeof( p ) { ##############################################

	return awk::typeof( p ) }

#___________________________________________________________
func	_default( v, dv ) { ##################################

	return isnull( v ) ? dv : v }

#___________________________________________________________
func	isnull( p ) { ########################################

	switch ( typeof( p ) ) {

		case "array":

			return

		case "untyped":

		case "undefined":

			return "U" } }

#___________________________________________________________
func	hid( n, c ) { ########################################

	if ( "hid::get" in FUNCTAB )

		return hid::get( n, c )

	if ( n == "" )

		n = "HID" ++_hid_cnt

	if ( n in hid::_NAMECODE )

		return hid::_NAMECODE[ n ]

	if ( c == "" )

		c = "\xFE" n "\xFE"

	hid::_NAMECODE[ HID[ c ] = n ] = c

	return c }

#___________________________________________________________
func	error( t, p0,p1,p2,p3 ,e ) { #########################

	ERRNO = message( t, p0,p1,p2,p3 )

	if ( e = ERROR_OUT ) {

		ERRNO = "fatal: " ERRNO

		print ERRNO >> e

		fflush( e )
		
		exit }

	ERRNO = "error: " ERRNO }

#_____________________________________________________
func	message( t, p0,p1,p2,p3 ) { ####################

	gsub( /@1/, msg_0( p0 ), t )
	gsub( /@2/, msg_0( p1 ), t )
	gsub( /@3/, msg_0( p2 ), t )
	gsub( /@4/, msg_0( p3 ), t )

	gsub( /!/, "", t )

	return t }
	#_____________________________

	func	msg_0( p ) {

		switch ( awk::typeof( p ) ) {

			case "untyped":

				return "-"

			case "array":

				return "A[]"

			case "undefined":

				return "-"

			default:

				return p "" } }

#___________________________________________________________
func	librq( n ) { #########################################

	if ( ! islib( n ) )

		return error( "@1 library requires @2 library", LIB, n ) }

	#_______________________________________________
	func	islib( n ) { #############################

		return ( "envmod::" n ) in FUNCTAB }

#_________________________________________________________________
##################################################################


