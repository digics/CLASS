
# ukazatel na klass: prosto uid::get() ???
# what if field-arrays having low and up-cased names ???? auto kill/autocopy
# _::new should report about undefined class ???


#_________________________________________________________________
# CLASS v1.0 ( 2024.11.9 ) #######################################
#
#	by digi_cs 2024
#
#	PLEASE DOWNLOAD LATEST VERSION FROM: github.com/digics/CLASS
#
#	THIS LIBRARY REQUIRES TWO ADDITIONAL LIBRARIES TO BE INCLUDED:
#
#		uid.lib			github.com/digics/UID10
#
#		arr.lib			github.com/digics/ARR
#
#_______________________________________________
#
#	- four basic methods implemented:
#
#		- _::def			define new class
#
#		- _::api			api request
#
#		- _::new			create new object of the class
#
#		- _::del			delete object
#
#	- superglobal arrays:
#
#		PARENT[ ptr ]			= pointer class ptr
#
#	   	CLASS[ ptr ]			= name
#
#	   	NAMECLASS[ name ]			= class ptr
#
#	- local arrays:
#
#	   	_PREFIX[ ptr ]			= prefix
#	   	_SUFFIX[ ptr ]			= suffix
#
#		_PFXSFX[ prefix SEP_ suffix ]	- srcptrs:
#
#		_SRCPTR[ ptr ]			= srcptr
#
#		_PTRLIST[ srcptr ][ ... ]	free ptr list array
#
#		+ UID-GENERATOR at [ srcptr ]
#
#	- special arrays:
#
#		_API
#		_APITAB
#
#		FUNC::TAB
#
#		NAMESPACE
#
#	- superglobal vars:
#
#		ALLPTR			??? regex to match with any ptr (incl. classes??) ???
#
#		CLASSPTR			??? regex to match with class ptrs???
#
#	- other resources:
#
#		ERROR_OUT var and error-events
#
#		BASEPTR (BASE_LEN, BASE_CS, BASE_PREFIX, BASE_SUFFIX)
#
#_________________________________________________________________
func	envmod::class( C ) { #######################################

	# environment registration: class
	#
	#_____________________________

	C[ "rq" ]		= "uid hid arr"

}#________________________________________________________________
##################################################################

@namespace   "class"

#_________________________________________________________________
BEGIN{ ###########################################################

	init0()

}#________________________________________________________________
func	init0( p,f,n,px,sx,A ) { ###################################

	if ( ! init0_f ) {

		init0_f = 1

		STDERR		= _default( STDERR	, "/dev/stderr/" )

		LIB			= "class"

		ERROR_OUT		= "/dev/stderr"		# _default( ERROR_OUT	, STDERR )

		librq( "uid" )
		librq( "hid" )
		librq( "arr" )

		SEP_ 			= hid( "SEP_" )
		#_______________________

		BASEPTR		= _default( BASEPTR	, _getclassptr()	)

		BASE_PREFIX		= _default( BASE_PREFIX	, "\x7F"		)
		BASE_SUFFIX		= _default( BASE_SUFFIX	, "\xC0\xC0\xFF"	)

		ALLPTR		= _default( ALLPTR	, "\x7F......\xFF" )
		#_______________________

		for ( f in FUNCTAB )

			if ( f in FUNC::TAB ) {

				if ( isnull( FUNC::TAB[ f ] ) )

					delete FUNC::TAB[ f ] }

			else {

				FUNC::TAB[ f ] = f

				match( f, /^(([^:]*)::)?([A-Z_a-z][0-9A-Z_a-z]*)$/, A )

				NAMESPACE[ A[ 2 ] ][ A[ 3 ] ] = "func" }
		
		_movaa( _API, NAMESPACE[ _letia( "_", NAMESPACE ) ] )

	#_______________________________________________
	# BASE CLASS DEFINITION ########################

		p	= BASEPTR

		n	= ""

		px	= BASE_PREFIX
		sx	= BASE_SUFFIX
		#_________________

		CLASS[ p ]		= n

		NAMECLASS[ n ]	= p

		_PREFIX[ p ]	= px
		_SUFFIX[ p ]	= sx

		f = px SEP_ sx

		_PFXSFX[ f ]	= p

		_SRCPTR[ p ]	= p

		uid::setcnt( p, px, sx )

		_defia( p, _PTRLIST )
		#_________________

 		f = "class::"

		FUNC::TAB[ p "::def" ]		= f "def"
		FUNC::TAB[ p "::api" ]		= f "api"
		FUNC::TAB[ p "::new" ]		= f "new"
		FUNC::TAB[ p "::del" ]		= f "del" } }

#_________________________________________________________________
func	_::def( n, pp, px, sx ,a,ap ) { ############################

	if ( ! init0_f )

		init0()
	#_____________________________
	#
	#	_::def( name, parentptr, prefix, suffix, p2,p3 )
	#
	#	n		defined class name
	#	pp		parent class ptr ( == "" (not undefined/untyped) - BASEPTR )
	#	px		uid prefix
	#	sx		uid suffix
	#_____________________________

	print

	switch ( typeof( pp ) ) {

		case "untyped":

		case "undefined":

			return def_err( "undefined! parent class: @2", n, null )

		default:

			if ( pp == "" )

				pp = BASEPTR

			if ( ! ( pp in CLASS ) )

				return def_err( "undefined! parent class: @2", n, pp ) }

	#_______________________

	a = n "::def"

	ap = pp "::def"

	if ( a in FUNC::TAB ) {

		API = FUNC::TAB[ a ]

		if ( ap in FUNC::TAB )

			if ( API != FUNC::TAB[ ap ] )

				_APITAB[ API ] = FUNC::TAB[ ap ] }

	else

		API = FUNC::TAB[ a ] = FUNC::TAB[ ap ]

	return @API( n, pp, px, sx ) }

	#_____________________________

	func	def_err( t, p0,p1,p2,p3 ) {

		return error( "_::def( @1, " t " )", p0,p1,p2,p3 ) }

	#_____________________________________________________
	func	def( n, pp, px, sx ,p ) { ######################

		# base class definition routine
		#
		#	n		defined class name
		#	pp		parent class ptr
		#	px		uid prefix
		#	sx		uid suffix
		#
		#	_::def( "name", parentptr, prefix, suffix )
		#_______________________

		if ( n in NAMECLASS )

			return def_err( "class name @1 redefinition!", n )
		#_________________

		if ( isnull( px ) )

			px = _PREFIX[ pp ]

		if ( isnull( sx ) )

			sx = _SUFFIX[ pp ]
		#_________________

		p = _getclassptr()

		print API "( " p ", " pp ", " n ", " px ", " sx " )"

		CLASS[ p ] = n

		NAMECLASS[ n ] = p

		def_srcptr( p, pp, px, sx )

		def_apinherit( p, pp )

		return p }

		#_______________________

		func	def_srcptr( p, pp, px, sx ,t ) {

			_PREFIX[ p ]	= px
			_SUFFIX[ p ]	= sx

			t = px SEP_ sx

			if ( t in _PFXSFX )

				_SRCPTR[ p ] = _PFXSFX[ t ]

			else

				uid::setcs( \
					_letia( \
						_PFXSFX[ t ] = _SRCPTR[ p ] = p, _PTRLIST ), px, sx, _SRCPTR[ pp ] ) }

		#_______________________

		func	def_apinherit( p, pp ,a,n,ac,ap ) {

			# for each _API: define self-class or parent-inherited method functions 
			#
			#	p		- defined class (ptr)
			#	pp		- parent class (ptr)
			#_________________

			n = CLASS[ p ]

			for ( a in _API ) {

				ac = n "::" a					# ac	- classname::method

				ap = pp "::" a					# ap	- parentptr::method

				if ( ac in FUNC::TAB ) {

					ac = FUNC::TAB[ ac ]

					FUNC::TAB[ p "::" a ] = ac

					if ( ap in FUNC::TAB )

						if ( ac != ap = FUNC::TAB[ ap ] )

							_APITAB[ ac ] = ap }

				else

					if ( ap in FUNC::TAB )

						FUNC::TAB[ p "::" a ] = FUNC::TAB[ ap ] } }

		#_______________________

		func	_getclassptr() {

			return uid::get() }

#___________________________________________________________
func	_::api( p, a ) { #####################################

	if ( ! init0_f )

		init0()
	#_____________________________
	#
	#	function (actually - method) for requesting method-functions
	#
	#	returns true in case if superglobvar API contains physical
	#	method-function name that's should be called to invoke a method
	#
	#	isapi( ptr, method )
	#
	#		request api-method for specified pointer/classptr
	#
	#	isapi( f )
	#
	#		parent method request using content of the given parameter f
	#
	#	isapi()
	#
	#		parent method request using content of the superglobvar API
	#
	#_____________________________

	if ( a == "" ) {

		if ( p == "" )

			p = API

		if ( p in _APITAB )

			return API = _APITAB[ p ] }

	else {

		PTR = p

		if ( p "::api" in FUNC::TAB )

			API = FUNC::TAB[ p "::api" ]

		else

			if ( p in PARENT )

				API = FUNC::TAB[ PARENT[ p ] "::api" ]

			else

				return p

		return API = @API( p, a ) } }

	#_______________________________________________
	func	api( p, a ) { ############################

		# request api-method for specified pointer/classptr
		#
		#	isapi( ptr, method )
		#_______________________

		print API "( " p ", " a " )"

		if ( p "::" a in FUNC::TAB )

			return FUNC::TAB[ p "::" a ]

		if ( p in PARENT )

			if ( ( p = PARENT[ p ] "::" a ) in FUNC::TAB )

				return FUNC::TAB[ p ] }

		#___________________________________
		func	isapi( p, a ) { ##############

			return _::api( p, a ) }

#___________________________________________________________
func	_::new( pp, p ) { ####################################

	if ( ! init0_f )

		init0()
	#_____________________________
	#
	#	create new ptr of the class pp
	#	if pp == "" then pp = BASEPTR
	#_____________________________

	switch ( typeof( pp ) ) {

		case "undefined":

		case "untyped":

			break

		default:

			if ( pp == "" )

				pp = BASEPTR

			if ( ! ( pp in CLASS ) )

				break

			if ( isapi( pp, "new" ) )

				return @API( pp, p ) }

	return new_err( "undefined parent class: @1", pp ) }

	#_____________________________

	func	new_err( t, p0,p1,p2,p3 ) {

		return error( "_::new( " t " )", p0,p1,p2,p3 ) }

	#_______________________________________________
	func	new( pp, p ,cp ) { #######################

		# create pointer of the class `pp (ptr)
		#
		#	returns ptr to the newly created ponter
		#
		#	pp	classptr
		#
		#	p	if != "" then p will be exact pointer string
		#_______________________

		print API "( " pp ", " p " )"

		if ( p == "" ) {

			cp = _SRCPTR[ pp ]

			if ( "" != p = _PTRLIST[ cp ][ "" ] ) {

				_PTRLIST[ cp ][ "" ] = _PTRLIST[ cp ][ p ]

				delete _PTRLIST[ cp ][ p ] }

			else

				p = uid::get( cp ) }

		PARENT[ p ] = pp

		return p }

#___________________________________________________________
func	_::del( p ) { ########################################

	if ( ! init0_f )

		init0()
	#_____________________________
	#
	#	delete pointer p
	#_____________________________

	if ( isapi( p, "del" ) )

		return @API( p ) }

	#_______________________________________________
	func	del( p ,pp ) { ###########################

		# delete pointer
		#
		#	p	ptr
		#_______________________

		print API "( " p " )"

		pp = PARENT[ p ]

		delete PARENT[ p ]

		pp = _SRCPTR[ pp ]

		_PTRLIST[ pp ][ _PTRLIST[ pp ][ "" ] = p ] = _PTRLIST[ pp ][ "" ] }

#_________________________________________________________________
func	typeof( p ) { ##############################################

	return awk::typeof( p ) }

#_____________________________________________________
func	typeofu( p ) { #################################

	switch ( typeof( p ) ) {

		case "untyped":

		case "undefined":

			return "untyped"

		default:

			return typeof( p ) } }






#_____________________________________________________
func	patsplit( t, A, r, B ) { #######################

	return awk::patsplit( t, A, r, B ) }

#___________________________________________________________
func	_movaa( D, S ) { #####################################

	return mov::aa( D, S ) }

#_____________________________________________________
func	_defia( i, A ) { ###############################

	return def::ia( p, A ) }

#_____________________________________________________
func	_letia( i, A ) { ###############################

	return let::ia( i, A ) }

#_____________________________________________________
func	_defiai( d, A, s ) { ###########################

	return def::iai( d, A, s ) }

#_____________________________________________________
func	_default( v, dv ) { ############################

	return isnull( v ) ? dv : v }

#_____________________________________________________
func	isnull( p ) { ##################################

	switch ( typeof( p ) ) {

		case "array":

			return

		case "untyped":

		case "undefined":

			return "U" } }

#___________________________________________________________
func	hid( n, c ) { ########################################

	if ( "hid::get" in FUNCTAB )

		return hid::get( n, c )

	if ( n == "" )

		n = "HID" ++_hid_cnt

	if ( n in hid::_NAMECODE )

		return hid::_NAMECODE[ n ]

	if ( c == "" )

		c = "\xFE" n "\xFE"

	hid::_NAMECODE[ HID[ c ] = n ] = c

	return c }

#___________________________________________________________
func	error( t, p0,p1,p2,p3 ,e ) { #########################

	ERRNO = message( t, p0,p1,p2,p3 )

	if ( e = ERROR_OUT ) {

		ERRNO = "fatal: " ERRNO

		print ERRNO >> e

		fflush( e )
		
		exit }

	ERRNO = "error: " ERRNO }

#_____________________________________________________
func	message( t, p0,p1,p2,p3 ) { ####################

	gsub( /@1/, msg_0( p0 ), t )
	gsub( /@2/, msg_0( p1 ), t )
	gsub( /@3/, msg_0( p2 ), t )
	gsub( /@4/, msg_0( p3 ), t )

	gsub( /!/, "", t )

	return t }
	#_____________________________

	func	msg_0( p ) {

		switch ( awk::typeof( p ) ) {

			case "untyped":

				return "-"

			case "array":

				return "A[]"

			case "undefined":

				return "-"

			default:

				return p "" } }

#___________________________________________________________
func	librq( n ) { #########################################

	if ( ! islib( n ) )

		return error( "@1 library requires @2 library", LIB, n ) }

	#_______________________________________________
	func	islib( n ) { #############################

		return "envmod::" n in FUNCTAB }

#_________________________________________________________________
##################################################################


