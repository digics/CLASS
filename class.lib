
# add record about 'base' class (not for "" )
# add log system

#_________________________________________________________________
# CLASS v1.0 ( 2024.11.11 ) ######################################
#
#	by digi_cs 2024
#
#	PLEASE DOWNLOAD LATEST VERSION FROM: github.com/digics/CLASS
#
#	THIS LIBRARY REQUIRES TWO ADDITIONAL LIBRARIES TO BE INCLUDED:
#
#		uid.lib			github.com/digics/UID10
#
#		arr.lib			github.com/digics/ARR
#
#_______________________________________________
#
#	- four basic methods implemented:
#
#		- _::def			define new class
#
#		- _::api			api request
#
#		- _::new			create new object of the class
#
#		- _::del			delete object
#
#	- superglobal arrays:
#
#		PARENT[ ptr ]			= pointer class ptr
#
#	   	CLASS[ ptr ]			= name
#
#	   	NAMECLASS[ name ]			= class ptr
#
#		PARENTPTR[ index ]		= class ptr
#
#			this array used by parentptr() function
#			normally it's having only one element:
#
#				PARENTPTR[ "" ]	= base class ptr
#
#					user may upgrade this pointer to implement higher base class
#					as default
#
#	- local arrays:
#
#	   	_PREFIX[ ptr ]			= prefix
#	   	_SUFFIX[ ptr ]			= suffix
#
#		_SRCPTR[ ptr ]			= srcptr
#
#		_PFXSFX[ prefix SEP_ suffix ]	= srcptr
#
#		_PTRLIST[ srcptr ][ ... ]	free ptr list array
#
#		+ UID-GENERATOR at [ srcptr ]
#
#	- special arrays:
#
#		_API
#
#		_APITAB
#
#		FUNC::TAB
#
#		NAMESPACE
#
#	- superglobal vars:
#
#		BASEPTR
#
#		ALLPTR			??? regex to match with any ptr (incl. classes??) ???
#
#		CLASSPTR			??? regex to match with class ptrs???
#
#	- other resources:
#
#		BASE_PREFIX
#
#		BASE_SUFFIX
#
#		ERROR_OUT
#
#		STDERR
#
#		NOT_METHOD
#
#			type: regexp
#
#			functions in namespace "_": if func name ~ NOTMETHODS_
#			then it's will be excluded from the api list in array _API
#
#		METHOD_SEP
#
#			the content of this var is included between class name and method name
#			while seeking for a method-functions
#
#			METHOD_SEP must start by "::" 
#
#_________________________________________________________________
func	envmod::class( C ) { #######################################

	C[ "ver" ]	= "100"

	C[ "rq" ]	= "uid( 1.01 )	" \
			  "hid( 1.01 )	" \
			  "arr( 1.01 )	" }

@namespace "class"

BEGIN{

	BASE_NAMESPACE = "class"

	init0() }




























#_________________________________________________________________
func	init0( p,f,n,px,sx,pp,A ) { ################################

	if ( ! init0_f ) {

		ERROR_OUT		= _default( ERROR_OUT	, STDERR, "/dev/stderr" )

		librq( "uid", "101" )
		librq( "hid", "101"  )
		librq( "arr", "101"  )

		SEP_ 			= hid( "SEP_" )
		#_______________________

		BASE_PREFIX		= _default( BASE_PREFIX	, "\x7F"		 )
		BASE_SUFFIX		= _default( BASE_SUFFIX	, "\xC0\xC0\xFF"	 )

		ALLPTR		= _default( ALLPTR	, "\x7F......\xFF" )

		METHOD_SEP		= _default( METHOD_SEP	, "::_" )

		NOT_METHOD		= _default( NOT_METHOD , "^_" )
		#_______________________

		for ( f in FUNCTAB )

			if ( f in FUNC::TAB ) {

				if ( isnull( FUNC::TAB[ f ] ) )

					delete FUNC::TAB[ f ] }

			else {

				FUNC::TAB[ f ] = f

				match( f, /^(([^:]*)::)?([A-Z_a-z][0-9A-Z_a-z]*)$/, A )

				NAMESPACE[ A[ 2 ] ][ A[ 3 ] ] = "func" }
		#_______________________
		
		movaa( _API, NAMESPACE[ letia( "_", NAMESPACE ) ] )

		for ( a in _API )

			if ( a ~ NOT_METHOD )

				delete _API[ a ]
	#_______________________________________________
	# BASE CLASS DEFINITION ########################

		n	= BASE_NAMESPACE

		px	= BASE_PREFIX
		sx	= BASE_SUFFIX

		p	= getclassptr()

		PARENTPTR[ "" ]	= p
		#_______________________

		CLASS[ p ]		= n

		NAMECLASS[ n ]	= p

		_PREFIX[ p ]	= px
		_SUFFIX[ p ]	= sx
		#_________________

		f = n METHOD_SEP

 		pp = p METHOD_SEP

		FUNC::TAB[ pp "def" ]		= f "def"
		FUNC::TAB[ pp "api" ]		= f "api"
		FUNC::TAB[ pp "new" ]		= f "new"
		FUNC::TAB[ pp "del" ]		= f "del"
		#_________________

		pp = uid()

		_SRCPTR[ p ] = pp

		_PFXSFX[ px SEP_ sx ] = pp

		uid::setcnt( pp, px, sx )

		defia( pp, _PTRLIST )

		init0_f = 1 } }























#_________________________________________________________________
func	_::def( n, pp, psx ,cm,pm ) { ##############################

	if ( ! init0_f )

		init0()
	#_____________________________
	#
	# (single) define new class `n
	#
	#	with parent `pp
	#	prefix/suffix determinated by `psx
	#_____________________________

	if ( isnull( pp ) )

		return def_err( "parentptr not specified" )

	if ( pp in PARENTPTR )

		pp = PARENTPTR[ pp ]

	if ( pp in CLASS ) {

		cm = n METHOD_SEP "def"

		pm = pp METHOD_SEP "def"

		if ( cm in FUNC::TAB ) {

			API = FUNC::TAB[ cm ]

			if ( pm in FUNC::TAB )

				if ( API != FUNC::TAB[ pm ] )

					_APITAB[ API ] = FUNC::TAB[ pm ] }

		else

			if ( pm in FUNC::TAB )

				API = FUNC::TAB[ cm ] = FUNC::TAB[ pm ]

			else

				API = null

		if ( API )

			return @API( n, pp, psx )

		else

			return def_err( "@2: def method missed", n, pp ) }

	else

		return def_err( "undefined parentptr: @2", n, pp ) }

	#_______________________

	func	def_err( t, p1,p2,p3,p4 ) {

		return error( "_::def( @1, " t " )", p1,p2,p3,p4 ) }

#___________________________________________________________
func	_::api( p, a ) { #####################################

	# (single) method-request for method-functions
	#
	#	p	- (ptr) pointer that's should be method applied
	#
	#	a	- (method) name of requested method
	#
	#	returns true in case if API contains physical
	#	method-function name that's should be called to invoke a method `a
	#
	#	_::api( ptr, method )
	#
	#		request api-method for specified pointer/classptr
	#
	#	_::api( p )
	#
	#		parent method request using content of the given parameter p
	#
	#	_::api()
	#
	#		parent method request using content of the superglobvar API
	#
	#_____________________________

	if ( a == "" ) {

		if ( p == "" )

			p = API

		if ( p in _APITAB )

			return API = _APITAB[ p ] }

	else {

		if ( p METHOD_SEP "api" in FUNC::TAB )

			API = FUNC::TAB[ p METHOD_SEP "api" ]

		else

			if ( p in PARENT )

				API = FUNC::TAB[ PARENT[ p ] METHOD_SEP "api" ]

			else

				return error( "api missed" )

		return API = @API( p, a ) } }

#___________________________________________________________
func	_::new( pp, p ,q,i,s,P,D ) { #########################

	# (multi/multipass) create new ptr `p of the class `pp
	#
	#_____________________________

	if ( isnull( pp ) )

		return new_err( "parentptr not specified" )

	if ( pp in PARENTPTR )

		pp = PARENTPTR[ pp ]
	#_______________________

	if ( pp in CLASS ) {

		if ( _::api( pp, "new" ) )

			return @API( pp, p )

		return new_err( "@1: new method missed", pp ) }
	#_______________________

	do {

		if ( q = patsplit( p, P, ALLPTR , D ) ) {

			for ( i = 1; i <= q; i++ )

				if ( ( s = P[ i ] ) in CLASS )

					if ( _::api( s, "new" ) )

						P[ i ] = @API( APIPTR )

					else

						return new_err( "@1: new method missed", pt ) }

		else

			return p

				} while ( p != p = retab( P, D ) )

	return p }
	#_____________________________

	func	new_err( t, p1,p2,p3,p4 ) {

		return error( "_::new( " t " )", p1,p2,p3,p4 ) } 

#___________________________________________________________
func	_::del( p ,q,i,s,P,D ) { #############################

	# (multi/multipass) delete `p
	#
	#_____________________________

	if ( p in PARENT ) {

		if ( _::api( p, "del" ) )

			return @API( p )

		return del_err( "@1: del method missed", p ) }
	#_______________________

	do {

		if ( q = patsplit( p, P, ALLPTR , D ) ) {

			for ( i = 1; i <= q; i++ )

				of ( ( s = P[ i ] ) in PARENT )

					if ( _::api( s, "del" ) )

						P[ i ] = @API( APIPTR ) }

		else

			return p		

				} while ( p != p = retab( P, D ) )

	return p }
	#_____________________________

	func	del_err( t, p1,p2,p3,p4 ) {

		return error( "_::del( " t " )", p1,p2,p3,p4 ) }
















#___________________________________________________________
func	_::w( p, t, p2,p3,p4,p5,p6,p7,p8 ) { #################

	# (single) write ptr `p
	#
	#_____________________________

	if ( isnull( p ) )

		return w_err( "no pointer" )

	if ( p in PARENTPTR )

		p = PARENTPTR[ p ]

	if ( p in CLASS )

		p = _::new( p )

	else

		if ( ! ( p in PARENT ) )

			return w_err( "bad pointer: @1", p )

	if ( _::api( p, "w" ) )

		return @API( APIPTR, t, p2,p3,p4,p5,p6,p7,p8 )

	return p }
	#_____________________________

	func	w_err( t, p1,p2,p3,p4 ) {

		return error( "_::w( " t " )", p1,p2,p3,p4 ) }

#___________________________________________________________
func	_::r( p, p1,p2,p3,p4,p5,p6,p7,p8 ,q,i,s,P,D ) { ######

	# (multi/multipass) read `p
	#
	#_____________________________

	if ( p in PARENT )

		if ( _::api( p, "r" ) )

			return @API( APIPTR, p1,p2,p3,p4,p5,p6,p7,p8 )

		else

			return p
	#_______________________

	do {

		if ( q = patsplit( p, P, ALLPTR , D ) ) {

			for ( i = 1; i <= q; i++ )

				if ( ( s = P[ i ] ) in PARENT )

					if ( _::api( s, "r" ) )

						P[ i ] = @API( APIPTR, p1,p2,p3,p4,p5,p6,p7,p8 ) }

		else

			return p		

				} while ( p != p = retab( P, D ) )

	return p }

























#_________________________________________________________________
func	_def( n, pp, px ,p,sx ) { ##################################

	print API "( " n ", " pp ", " px " )"

	#_______________________
	#
	# base class definition
	#
	#	n		defined class name
	#	pp		parent class ptr
	#	px		prefix/suffix str
	#_______________________

	if ( n in NAMECLASS )

		return def_err( "class name @1 redefinition!", n )
	#_________________

	p = n "::init0"

	if ( p in FUNC::TAB ) {

		p = FUNC::TAB[ p ]

		@p() }
	#_________________

	def_psfx( px, pp ) 

	px = PFX_; sx = SFX_
	#_________________

	p = getclassptr()

	CLASS[ p ]		= n

	NAMECLASS[ n ]	= p

	_PREFIX[ p ]	= px
	_SUFFIX[ p ]	= sx

	_SRCPTR[ p ]	= def_srcptr( p, pp, px, sx )

	def_apinherit( p, pp )

	return p }
	#_______________________

	func	def_psfx( t, pp ,P ) {

		if ( t == "" )

			t = ".|."

		if ( 1 == split( t, P, /\|/ ) ) {

			PFX_ = _PREFIX[ pp ]

			SFX_ = t }

		else {

			PFX_ = def_psfx_0( P[ 1 ], _PREFIX[ pp ] )

			SFX_ = def_psfx_0( P[ 2 ], _SUFFIX[ pp ] ) } }
		#___________

		func	def_psfx_0( p, pp ) {

			return p == "." ? pp : p }
	#_______________________

	func	def_srcptr( p, pp, px, sx ,t ) {

		t = px SEP_ sx

		if ( t in _PFXSFX )

			return _PFXSFX[ t ]

		p = uid()

		_PFXSFX[ t ] = p

		letia( p, _PTRLIST )

		uid::setcs( p, px, sx, _SRCPTR[ pp ] )

		return p }
	#_______________________

	func	def_apinherit( p, pp ,s,a,n,ac,ap ) {

		# for each _API: define self-class or parent-inherited method functions 
		#
		#	p		- defined class (ptr)
		#	pp		- parent class (ptr)
		#___________

		s = METHOD_SEP

		n = CLASS[ p ]

		for ( a in _API ) {

			ac = n s a				# ac	- classname::_method

			ap = pp s a				# ap	- parentptr::_method

			if ( ac in FUNC::TAB ) {

				ac = FUNC::TAB[ ac ]

				FUNC::TAB[ p s a ] = ac

				if ( ap in FUNC::TAB )

					if ( ac != ap = FUNC::TAB[ ap ] )

						_APITAB[ ac ] = ap }

			else

				if ( ap in FUNC::TAB )

					FUNC::TAB[ p s a ] = FUNC::TAB[ ap ] } }
	#_______________________

	func	getclassptr() {

		return uid() }

#___________________________________________________________
func	_api( p, a ) { #######################################

	# request api-method for specified pointer/classptr
	#
	#	isapi( ptr, method )
	#_______________________

	print API "( " p ", " a " )"

	APIPTR = p

	if ( p METHOD_SEP a in FUNC::TAB )

		return FUNC::TAB[ p METHOD_SEP a ]

	if ( p in PARENT )

		if ( ( p = PARENT[ p ] METHOD_SEP a ) in FUNC::TAB )

			return FUNC::TAB[ p ] }

#___________________________________________________________
func	_new( pp, p ,cp ) { ##################################

	# create pointer `p of the class `pp
	#
	#	returns ptr to the newly created ponter
	#
	#	if pp == "" then pp = PARENTPTR[ "" ] (base method)
	#
	#	if pp is not defined class then perform error:
	#
	#		undefined parent class: pp
	#
	#	if p != "" then p will be exact pointer to the created object
	#
	#	if p == "" then p will be generated 
	#_______________________

	print API "( " pp ", " p " )"

	if ( p == "" ) {

		cp = _SRCPTR[ pp ]

		if ( "" != p = _PTRLIST[ cp ][ "" ] ) {

			_PTRLIST[ cp ][ "" ] = _PTRLIST[ cp ][ p ]

			delete _PTRLIST[ cp ][ p ] }

		else

			p = uid( cp ) }

	PARENT[ p ] = pp

	return p }

#___________________________________________________________
func	_del( p ,pp ) { ######################################

	# delete pointer ptr
	#
	#	returns null
	#
	#	p	ptr
	#_______________________

	print API "( " p " )"

	pp = PARENT[ p ]

	delete PARENT[ p ]

	pp = _SRCPTR[ pp ]

	_PTRLIST[ pp ][ _PTRLIST[ pp ][ "" ] = p ] = _PTRLIST[ pp ][ "" ] }






















#_________________________________________________________________
func	librq( n, v ) { ############################################

	if ( ! islib( n ) )

		return error( "class library requires @1 library", n ) }

	#_____________________________

	func	islib( n ) {

		return ( "envmod::" n ) in FUNCTAB }

#_____________________________________________________
func	error( t, p1,p2,p3,p4, e ) { ###################

	if ( t == "" )

		t = "@1"

	ERRNO = message( t, p1,p2,p3,p4 )

	if ( isnull( e ) )

		e = ERROR_OUT

	if ( e ) {

		ERRNO = "fatal: " ERRNO

		ORS = "\x0A"				# ??? EOL???

		print ERRNO >> e

		fflush( e )
		
		exit }

	ERRNO = "error: " ERRNO }

	#_______________________

	func	message( t, p1,p2,p3,p4 ) {

		gsub( /@1/, msg_0( p1 ), t )
		gsub( /@2/, msg_0( p2 ), t )
		gsub( /@3/, msg_0( p3 ), t )
		gsub( /@4/, msg_0( p4 ), t )

		gsub( /!/, "", t )

		return t }
		#_________________

		func	msg_0( p ) {

			switch ( typeof( p ) ) {

				case "untyped":

					return "-"

				case "array":

					return "A[]"

				case "undefined":

					return "-"

				default:

					return p "" } }

#_____________________________________________________
func	typeof( p ) { ##################################

	return awk::typeof( p ) }

#_______________________________________________
func	patsplit( t, A, r, B ) { #################

	return awk::patsplit( t, A, r, B ) }

#_____________________________________________________
func	movaa( D, S ) { ################################

	return mov::aa( D, S ) }

#_______________________________________________
func	defia( i, A ) { ##########################

	return def::ia( p, A ) }

#_______________________________________________
func	letia( i, A ) { ##########################

	return let::ia( i, A ) }
#_____________________________________________________
func	retab( A, B ) { ################################

	return ret::ab( A, B ) }

#_____________________________________________________
func	isapi( p, a ) { ################################

	return _::api( p, a ) }

#_______________________________________________
func	uid( pp ) { ##############################

	return uid::get( pp ) }

#_______________________________________________
func	hid( n, c ) { ############################

	return hid::get( n, c ) }

#_____________________________________________________
func	isnull( p ) { ##################################

	switch ( typeof( p ) ) {

		case "array":

			return

		case "untyped":

		case "undefined":

			return "U" } }

#_______________________________________________
func	_default( v, dv, dv2 ) { #################

	if ( isnull( v ) )

		if ( isnull( dv ) )

			return dv2

		else

			return dv

	return v }

#_________________________________________________________________
##################################################################


