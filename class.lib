
# add record about 'base' class (not for "" )
# add log system

#_________________________________________________________________
# CLASS v1.0 ( 2024.11.11 ) ######################################
#
#	by digi_cs 2024
#
#	PLEASE DOWNLOAD LATEST VERSION FROM: github.com/digics/CLASS
#
#	THIS LIBRARY REQUIRES TWO ADDITIONAL LIBRARIES TO BE INCLUDED:
#
#		uid.lib			github.com/digics/UID10
#
#		arr.lib			github.com/digics/ARR
#
#_______________________________________________
#
#	- four basic methods implemented:
#
#		- _::def			define new class
#
#		- _::api			api request
#
#		- _::new			create new object of the class
#
#		- _::del			delete object
#
#	- superglobal arrays:
#
#		PARENT[ ptr ]			= pointer class ptr
#
#	   	CLASS[ ptr ]			= name
#
#	   	NAMECLASS[ name ]			= class ptr
#
#		PARENTPTR[ index ]		= class ptr
#
#			this array used by parentptr() function
#			normally it's having only one element:
#
#				PARENTPTR[ "" ]	= base class ptr
#
#					user may upgrade this pointer to implement higher base class
#					as default
#
#	- local arrays:
#
#	   	_PREFIX[ ptr ]			= prefix
#	   	_SUFFIX[ ptr ]			= suffix
#
#		_SRCPTR[ ptr ]			= srcptr
#
#		_PFXSFX[ prefix SEP_ suffix ]	= srcptr
#
#		_PTRLIST[ srcptr ][ ... ]	free ptr list array
#
#		+ UID-GENERATOR at [ srcptr ]
#
#	- special arrays:
#
#		_API
#
#		_APITAB
#
#		FUNC::TAB
#
#		NAMESPACE
#
#	- superglobal vars:
#
#		BASEPTR
#
#		ALLPTR			??? regex to match with any ptr (incl. classes??) ???
#
#		CLASSPTR			??? regex to match with class ptrs???
#
#	- other resources:
#
#		BASE_PREFIX
#
#		BASE_SUFFIX
#
#		ERROR_OUT
#
#		STDERR
#
#		NOTMETHODS_
#
#			type: regexp
#
#			functions in namespace "_": if func name ~ NOTMETHODS_
#			then it's will be excluded from the api list in array _API
#
#		METHOD_SEP
#
#			the content of this var is included between class name and method name
#			while seeking for a method-functions
#
#			METHOD_SEP must start by "::" 
#
#_________________________________________________________________
func	envmod::base( C ) { ########################################

	C[ "ver" ]	= "100"

	C[ "rq" ]	= "uid( 1.01 )	" \
			  "hid( 1.01 )	" \
			  "arr( 1.01 )	" }

@namespace   "base"

BEGIN{

	_init0() }

#_________________________________________________________________
func	_init0( p,f,n,px,sx,pp,A ) { ###############################

	if ( ! _init0_f ) {

		ERROR_OUT		= _default( ERROR_OUT	, STDERR, "/dev/stderr" )

		librq( "uid", "101" )
		librq( "hid", "101"  )
		librq( "arr", "101"  )

		SEP_ 			= hid( "SEP_" )
		#_______________________

		BASE_PREFIX		= _default( BASE_PREFIX	, "\x7F"		  )
		BASE_SUFFIX		= _default( BASE_SUFFIX	, "\xC0\xC0\xFF"	  )

		ALLPTR		= _default( ALLPTR	, "\x7F......\xFF"  )

		METHOD_SEP		= _default( METHOD_SEP	, "::_" )

		NOTMETHODS_		= _default( NOTMETHODS_ , "^_" )
		#_______________________

		for ( f in FUNCTAB )

			if ( f in FUNC::TAB ) {

				if ( isnull( FUNC::TAB[ f ] ) )

					delete FUNC::TAB[ f ] }

			else {

				FUNC::TAB[ f ] = f

				match( f, /^(([^:]*)::)?([A-Z_a-z][0-9A-Z_a-z]*)$/, A )

				NAMESPACE[ A[ 2 ] ][ A[ 3 ] ] = "func" }
		#_______________________
		
		movaa( _API, NAMESPACE[ letia( "_", NAMESPACE ) ] )

		for ( a in _API )

			if ( a ~ NOTMETHODS_ )

				delete _API[ a ]
	#_______________________________________________
	# BASE CLASS DEFINITION ########################

		n	= ""

		p	= getclassptr()
		#_______________________

		PARENTPTR[ n ]	= p

		px	= BASE_PREFIX
		sx	= BASE_SUFFIX
		#_________________

		CLASS[ p ]		= n

		NAMECLASS[ n ]	= p

		_PREFIX[ p ]	= px
		_SUFFIX[ p ]	= sx
		#_________________

 		pp = p METHOD_SEP

		f = "base" METHOD_SEP

		FUNC::TAB[ pp "def" ]		= f "def"
		FUNC::TAB[ pp "api" ]		= f "api"
		FUNC::TAB[ pp "new" ]		= f "new"
		FUNC::TAB[ pp "del" ]		= f "del"
		#_________________

		_SRCPTR[ p ] = pp = uid()

		_PFXSFX[ px SEP_ sx ] = pp

		uid::setcnt( pp, px, sx )

		defia( pp, _PTRLIST )

		_init0_f = 1 } }

#_________________________________________________________________
func	parentptr( pp, t, p2,p3,p4 ) { #############################

	if ( ! isnull( pp )  ) {

		if ( pp in PARENTPTR )

			pp = PARENTPTR[ pp ]

		if ( pp in CLASS )

			return pp }

	return error( t, message( "undefined! parent class: @1", pp ), p2,p3,p4 ) }

#___________________________________________________________
func	getclassptr() { ######################################

	return uid() }





























#_________________________________________________________________
func	_::def( n, pp, px, sx ,a,ap ) { ############################

	if ( ! _init0_f )

		_init0()
	#_____________________________
	#
	#	_::def( name, parentptr, prefix, suffix )
	#
	#	n		defined class name
	#	pp		parent class ptr ( == "" (not undefined/untyped) - BASEPTR )
	#	px		uid prefix
	#	sx		uid suffix
	#_____________________________

	pp = parentptr( pp, "_::def( @2, @1 )", n )

	a = n METHOD_SEP "def"

	ap = pp METHOD_SEP "def"

	if ( a in FUNC::TAB ) {

		API = FUNC::TAB[ a ]

		if ( ap in FUNC::TAB )

			if ( API != FUNC::TAB[ ap ] )

				_APITAB[ API ] = FUNC::TAB[ ap ] }

	else

		API = FUNC::TAB[ a ] = FUNC::TAB[ ap ]

	return @API( n, pp, px, sx ) }

	#_________________________________________
	func	_def( n, pp, px, sx ,p ) { #########

		# base class definition routine
		#
		#	n		defined class name
		#	pp		parent class ptr
		#	px		uid prefix
		#	sx		uid suffix
		#
		#	_::def( "name", parentptr, prefix, suffix )
		#_______________________

		if ( n in NAMECLASS )

			return def_err( "class name @1 redefinition!", n )
		#_________________

		if ( isnull( px ) )

			px = _PREFIX[ pp ]

		if ( isnull( sx ) )

			sx = _SUFFIX[ pp ]
		#_________________

		p = getclassptr()

		# log( API "( " p ", " pp ", " n ", " px ", " sx " )" )

		print API "( " p ", " pp ", " n ", " px ", " sx " )"

		CLASS[ p ]		= n

		NAMECLASS[ n ]	= p

		_PREFIX[ p ]	= px
		_SUFFIX[ p ]	= sx

		_SRCPTR[ p ]	= def_srcptr( p, pp, px, sx )

		def_apinherit( p, pp )

		return p }

		#_______________________

		func	def_srcptr( p, pp, px, sx ,t ) {

			t = px SEP_ sx

			if ( t in _PFXSFX )

				return _PFXSFX[ t ]

			p = uid()

			_PFXSFX[ t ] = p

			letia( p, _PTRLIST )

			uid::setcs( p, px, sx, _SRCPTR[ pp ] )

			return p }

		#_______________________

		func	def_apinherit( p, pp ,s,a,n,ac,ap ) {

			# for each _API: define self-class or parent-inherited method functions 
			#
			#	p		- defined class (ptr)
			#	pp		- parent class (ptr)
			#_________________

			s = METHOD_SEP

			n = CLASS[ p ]

			for ( a in _API ) {

				ac = n s a				# ac	- classname::_method

				ap = pp s a				# ap	- parentptr::_method

				if ( ac in FUNC::TAB ) {

					ac = FUNC::TAB[ ac ]

					FUNC::TAB[ p s a ] = ac

					if ( ap in FUNC::TAB )

						if ( ac != ap = FUNC::TAB[ ap ] )

							_APITAB[ ac ] = ap }

				else

					if ( ap in FUNC::TAB )

						FUNC::TAB[ p s a ] = FUNC::TAB[ ap ] } }
	#_____________________________

	func	def_err( t, p1,p2,p3,p4 ) {

		return error( "_::def( @1, " t " )", p1,p2,p3,p4 ) }

#_____________________________________________________
func	_::api( p, a ) { ###############################

	if ( ! _init0_f )

		_init0()
	#_____________________________
	#
	# method for requesting method-functions
	#
	#	p	- (ptr) pointer that's should be method applied
	#
	#	a	- (method) name of requested method
	#
	#	returns true in case if API contains physical
	#	method-function name that's should be called to invoke a method `a
	#
	#	_::api( ptr, method )
	#
	#		request api-method for specified pointer/classptr
	#
	#	_::api( p )
	#
	#		parent method request using content of the given parameter p
	#
	#	_::api()
	#
	#		parent method request using content of the superglobvar API
	#
	#_____________________________

	if ( a == "" ) {

		if ( p == "" )

			p = API

		if ( p in _APITAB )

			return API = _APITAB[ p ] }

	else {

		PTR = p

		if ( p METHOD_SEP "api" in FUNC::TAB )

			API = FUNC::TAB[ p METHOD_SEP "api" ]

		else

			if ( p in PARENT )

				API = FUNC::TAB[ PARENT[ p ] METHOD_SEP "api" ]

			else

				return p

		return API = @API( p, a ) } }

	#_________________________________________
	func	_api( p, a ) { #####################

		# request api-method for specified pointer/classptr
		#
		#	isapi( ptr, method )
		#_______________________

		print API "( " p ", " a " )"

		METHOD = a

		if ( p METHOD_SEP a in FUNC::TAB )

			return FUNC::TAB[ p METHOD_SEP a ]

		if ( p in PARENT )

			if ( ( p = PARENT[ p ] METHOD_SEP a ) in FUNC::TAB )

				return FUNC::TAB[ p ] }

#_____________________________________________________
func	_::new( pp, p ,e ) { ###########################

	if ( ! _init0_f )

		_init0()
	#_____________________________
	#
	#	create new ptr of the class pp
	#	if pp == "" then pp = BASEPTR
	#_____________________________

	e = "_::new( @1 )"

	pp = parentptr( pp, e )

	return runapi1( pp, "new", e, p ) }

	#_________________________________________
	func	_new( pp, p ,cp ) { ################

		# create pointer of the class `pp (ptr)
		#
		#	returns ptr to the newly created ponter
		#
		#	pp	classptr
		#
		#	p	if != "" then p will be exact pointer string
		#_______________________

		print API "( " pp ", " p " )"

		if ( isnull( p ) ) {

			cp = _SRCPTR[ pp ]

			if ( "" != p = _PTRLIST[ cp ][ "" ] ) {

				_PTRLIST[ cp ][ "" ] = _PTRLIST[ cp ][ p ]

				delete _PTRLIST[ cp ][ p ] }

			else

				p = uid( cp ) }

		PARENT[ p ] = pp

		return p }

#_____________________________________________________
func	_::del( p ) { ##################################

	if ( ! _init0_f )

		_init0()
	#_____________________________
	#
	#	delete pointer p
	#_____________________________

	return runapi0( p, "del", "_::del( @1 )" ) }

	#_________________________________________
	func	_del( p ,pp ) { ####################

		# delete pointer base method
		#
		#	returns null
		#
		#	p	ptr
		#_______________________

		print API "( " p " )"

		pp = PARENT[ p ]

		delete PARENT[ p ]

		pp = _SRCPTR[ pp ]

		_PTRLIST[ pp ][ _PTRLIST[ pp ][ "" ] = p ] = _PTRLIST[ pp ][ "" ] }

#___________________________________________________________
func	librq( n, v ) { ######################################

	if ( ! islib( n ) )

		return error( "@1 library requires @2 library", "base", n ) }

	#_____________________________

	func	islib( n ) {

		return ( "envmod::" n ) in FUNCTAB }

#_____________________________________________________
func	error( t, p1,p2,p3,p4, e ) { ###################

	if ( t == "" )

		t = "@1"

	ERRNO = message( t, p1,p2,p3,p4 )

	if ( isnull( e ) )

		e = ERROR_OUT

	if ( e ) {

		ERRNO = "fatal: " ERRNO

		print ERRNO >> e

		fflush( e )
		
		exit }

	ERRNO = "error: " ERRNO }

	#_______________________

	func	message( t, p1,p2,p3,p4 ) {

		gsub( /@1/, msg_0( p1 ), t )
		gsub( /@2/, msg_0( p2 ), t )
		gsub( /@3/, msg_0( p3 ), t )
		gsub( /@4/, msg_0( p4 ), t )

		gsub( /!/, "", t )

		return t }
		#_________________

		func	msg_0( p ) {

			switch ( typeof( p ) ) {

				case "untyped":

					return "-"

				case "array":

					return "A[]"

				case "undefined":

					return "-"

				default:

					return p "" } }

#_____________________________________________________
func	typeof( p ) { ##################################

	return awk::typeof( p ) }

#_______________________________________________
func	patsplit( t, A, r, B ) { #################

	return awk::patsplit( t, A, r, B ) }

#_____________________________________________________
func	movaa( D, S ) { ################################

	return mov::aa( D, S ) }

#_______________________________________________
func	defia( i, A ) { ##########################

	return def::ia( p, A ) }

#_______________________________________________
func	letia( i, A ) { ##########################

	return let::ia( i, A ) }

#_____________________________________________________
func	isapi( p, a ) { ################################

	return _::api( p, a ) }

#_______________________________________________
func	uid( pp ) { ##############################

	return uid::get( pp ) }

#_______________________________________________
func	hid( n, c ) { ############################

	return hid::get( n, c ) }

#_____________________________________________________
func	isnull( p ) { ##################################

	switch ( typeof( p ) ) {

		case "array":

			return

		case "untyped":

		case "undefined":

			return "U" } }

#_______________________________________________
func	_default( v, dv, dv2 ) { #################

	if ( isnull( v ) )

		if ( isnull( dv ) )

			return dv2

		else

			return dv

	return v }

#_________________________________________________________________
##################################################################


































#___________________________________________________________
func	callapi4( p, a, p1,p2,p3,p4 ) { ######################

	if ( _::api( p, a ) )

		return @API( p, p1,p2,p3,p4 )

	return p }
	#___________________________________

	func	callapi3( p, a, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p, p1,p2,p3 )

		return p }

	#___________________________________

	func	callapi2( p, a, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p, p1,p2 )

		return p }

	#___________________________________

	func	callapi1( p, a, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p, p1 )

		return p }
	#___________________________________

	func	callapi0( p, a, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p )

		return p }

#___________________________________________________________
func	runapi4( p, a, e, p1,p2,p3,p4 ) { ####################

	if ( _::api( p, a ) )

		return @API( p, p1,p2,p3,p4 )

	return error( e, message( "@1::@2 api missed", p, a ), p1,p2,p3 ) }
	#___________________________________

	func	runapi3( p, a, e, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p, p1,p2,p3 )

		return error( e, message( "@1::@2 api missed", p, a ), p1,p2,p3 ) }
	#___________________________________

	func	runapi2( p, a, e, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p, p1,p2 )

		return error( e, message( "@1::@2 api missed", p, a ), p1,p2,p3 ) }
	#___________________________________

	func	runapi1( p, a, e, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p, p1 )

		return error( e, message( "@1::@2 api missed", p, a ), p1,p2,p3 ) }
	#___________________________________

	func	runapi0( p, a, e, p1,p2,p3,p4 ) {

		if ( _::api( p, a ) )

			return @API( p )

		return error( e, message( "@1::@2 api missed", p, a ), p1,p2,p3 ) }

#___________________________________________________________
func	ppapi4( p, p1,p2,p3,p4 ) { ###########################

	return callapi4( null, null, p, p1,p2,p3,p4 ) }
	#___________________________________

	func	ppapi3( p1,p2,p3,p4 ) {

		return callapi3( null, null, p, p1,p2,p3,p4 ) }
	#___________________________________

	func	ppapi2( p1,p2,p3,p4 ) {

		return callapi2( null, null, p, p1,p2,p3,p4 ) }
	#___________________________________

	func	ppapi1( p1,p2,p3,p4 ) {

		return callapi1( null, null, p1,p2,p3,p4 ) }
	#___________________________________

	func	ppapi0( p1,p2,p3,p4 ) {

		return callapi0( null, null, p1,p2,p3,p4 ) }







































